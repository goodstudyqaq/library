[
    {
        "created": "2023-01-19T07:32:08.591Z",
        "name": "mc++",
        "tags": [
            "cpp"
        ],
        "content": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"copypaste/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\nvoid solve() {\n\n}\n\nint main() {\n#ifdef LOCAL\n    freopen(\"./data.in\", \"r\", stdin);\n#endif\n\n    int T;\n    cin >> T;\n    while (T--) {\n        solve();\n    }\n    return 0;\n}",
        "contentType": "cpp"
    },
    {
        "created": "2022-02-17T15:49:16.206Z",
        "name": "c++",
        "tags": [
            "cpp"
        ],
        "content": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include \"copypaste/debug.h\"\n#else\n#define debug(...) 42\n#endif\n\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\nint main() {\n#ifdef LOCAL\n    freopen(\"./data.in\", \"r\", stdin);\n#endif\n}",
        "contentType": "cpp"
    },
    {
        "created": "2022-03-22T04:34:38.385Z",
        "name": "get_mod",
        "tags": [
            "cpp"
        ],
        "content": "template <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\n   public:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod())\n            v = static_cast<Type>(x);\n        else\n            v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular& operator-=(const Modular& other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template <typename U>\n    Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U>\n    Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(int) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n            \"divl %4; \\n\\t\"\n            : \"=a\"(d), \"=d\"(m)\n            : \"d\"(xh), \"a\"(xl), \"r\"(mod()));\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, long long>::value, Modular>::type& operator*=(const Modular& rhs) {\n        long long q = static_cast<long long>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    friend const Type& abs(const Modular& x) { return x.value; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename V, typename U>\n    friend V& operator>>(V& stream, Modular<U>& number);\n\n   private:\n    Type value;\n};\n\ntemplate <typename T>\nbool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U>\nbool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U>\nbool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T>\nbool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U>\nbool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U>\nbool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T>\nbool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T>\nModular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U>\nModular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U>\nModular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T>\nModular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T>\nModular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T>\nModular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U>\nModular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate <typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\n// U == std::ostream? but done this way because of fastoutput\ntemplate <typename U, typename T>\nU& operator<<(U& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\n// U == std::istream? but done this way because of fastinput\ntemplate <typename U, typename T>\nU& operator>>(U& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, long long>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\n/*\nusing ModType = int;\n \nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nvector<Mint> fact(1);\nvector<Mint> inv_fact(1);\n \nMint C(int n, int k) {\n  if (k < 0 || k > n) {\n    return 0;\n  }\n  fact[0] = inv_fact[0] = 1;\n  while ((int) fact.size() < n + 1) {\n    fact.push_back(fact.back() * (int) fact.size());\n    inv_fact.push_back(1 / fact.back());\n  }\n  return fact[n] * inv_fact[k] * inv_fact[n - k];\n}\n\nMint A(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    fact[0] = inv_fact[0] = 1;\n\n    while ((int)fact.size() < n + 1) {\n        fact.push_back(fact.back() * (int)fact.size());\n        inv_fact.push_back(1 / fact.back());\n    }\n    return fact[n] * inv_fact[n - k];\n}\n",
        "contentType": "cpp"
    },
    {
        "created": "2022-03-22T04:46:41.432Z",
        "name": "get_utils",
        "tags": [
            "cpp"
        ],
        "content": "template <class T>\nauto vect(const T& v, int n) { return vector<T>(n, v); }\ntemplate <class T, class... D>\nauto vect(const T& v, int n, D... m) {\n    return vector<decltype(vect(v, m...))>(n, vect(v, m...));\n}\n\ntemplate <typename T>\nstatic constexpr T inf = numeric_limits<T>::max() / 2;\nmt19937_64 mrand(random_device{}());\nlong long rnd(long long x) { return mrand() % x; }\nint lg2(long long x) { return sizeof(long long) * 8 - 1 - __builtin_clzll(x); }\n\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\n\ntypedef pair<int, int> pii;\ntypedef tree<pii, null_type, less<pii>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n",
        "contentType": "cpp"
    }
]